// package.json
{
  "name": "generate-lyrics",
  "version": "1.0.0",
  "description": "Generate song lyrics using Anthropic AI",
  "main": "src/index.js",
  "type": "module",
  "scripts": {
    "setup": "node src/setup.js"
  },
  "dependencies": {
    "node-appwrite": "^14.0.0",
    "@anthropic-ai/sdk": "^0.24.3"
  }
}

// src/setup.js
import { Client, Databases } from 'node-appwrite';
import { DATABASE_CONFIG } from './config.js';

/**
 * Setup script to ensure database and collections exist
 * This runs during the build process
 */
const setup = async () => {
  console.log('Setting up database for generate-lyrics function...');
  
  try {
    const client = new Client()
      .setEndpoint(process.env.APPWRITE_FUNCTION_API_ENDPOINT)
      .setProject(process.env.APPWRITE_FUNCTION_PROJECT_ID)
      .setKey(process.env.APPWRITE_FUNCTION_API_KEY);
    
    const databases = new Databases(client);
    
    // Check if database exists
    try {
      await databases.get(DATABASE_CONFIG.DATABASE_ID);
      console.log('Database exists');
    } catch (error) {
      if (error.code === 404) {
        console.log('Creating database...');
        await databases.create(
          DATABASE_CONFIG.DATABASE_ID,
          DATABASE_CONFIG.DATABASE_NAME
        );
      } else {
        throw error;
      }
    }
    
    // Check collections
    for (const collection of DATABASE_CONFIG.COLLECTIONS) {
      try {
        await databases.getCollection(DATABASE_CONFIG.DATABASE_ID, collection.id);
        console.log(`Collection ${collection.id} exists`);
      } catch (error) {
        if (error.code === 404) {
          console.log(`Creating collection ${collection.id}...`);
          await databases.createCollection(
            DATABASE_CONFIG.DATABASE_ID,
            collection.id,
            collection.name,
            collection.permissions,
            collection.documentSecurity
          );
          
          // Create attributes
          for (const attr of collection.attributes) {
            console.log(`Creating attribute ${attr.key}...`);
            await createAttribute(databases, collection.id, attr);
          }
        } else {
          throw error;
        }
      }
    }
    
    console.log('Setup completed successfully');
  } catch (error) {
    console.error('Setup failed:', error);
    process.exit(1);
  }
};

const createAttribute = async (databases, collectionId, attr) => {
  const baseParams = [
    DATABASE_CONFIG.DATABASE_ID,
    collectionId,
    attr.key,
    attr.required
  ];
  
  switch (attr.type) {
    case 'string':
      await databases.createStringAttribute(
        ...baseParams,
        attr.size,
        attr.default,
        attr.array
      );
      break;
    case 'boolean':
      await databases.createBooleanAttribute(
        ...baseParams,
        attr.default,
        attr.array
      );
      break;
    case 'datetime':
      await databases.createDatetimeAttribute(
        ...baseParams,
        attr.default,
        attr.array
      );
      break;
  }
};

setup();

// src/config.js
export const DATABASE_CONFIG = {
  DATABASE_ID: 'mitchly-music-db',
  DATABASE_NAME: 'Mitchly Music Database',
  COLLECTIONS: [
    {
      id: 'bands',
      name: 'Bands',
      permissions: [],
      documentSecurity: true,
      attributes: [
        { key: 'bandName', type: 'string', size: 255, required: true },
        { key: 'profileData', type: 'string', size: 10000, required: false },
        { key: 'primaryGenre', type: 'string', size: 100, required: false },
        { key: 'createdAt', type: 'datetime', required: true, default: null }
      ]
    },
    {
      id: 'songs',
      name: 'Songs',
      permissions: [],
      documentSecurity: true,
      attributes: [
        { key: 'title', type: 'string', size: 255, required: true },
        { key: 'trackNumber', type: 'string', size: 10, required: true },
        { key: 'bandId', type: 'string', size: 36, required: false },
        { key: 'description', type: 'string', size: 1000, required: false },
        { key: 'aiInstructions', type: 'string', size: 1000, required: false },
        { key: 'primaryGenre', type: 'string', size: 100, required: false },
        { key: 'lyrics', type: 'string', size: 10000, required: false },
        { key: 'status', type: 'string', size: 50, required: true, default: 'draft' },
        { key: 'lyricsGeneratedAt', type: 'datetime', required: false },
        { key: 'generationError', type: 'string', size: 1000, required: false }
      ]
    }
  ]
};

// src/services/AnthropicService.js
import Anthropic from '@anthropic-ai/sdk';

export class AnthropicService {
  constructor(apiKey) {
    if (!apiKey) {
      throw new Error('Anthropic API key is required');
    }
    
    this.client = new Anthropic({ apiKey });
  }
  
  /**
   * Generate lyrics based on band and song context
   * @param {Object} context - The context for lyrics generation
   * @returns {Promise<{songDescription: string, lyrics: string}>}
   */
  async generateLyrics(context) {
    const { bandProfile, songDetails } = context;
    
    const prompt = this.buildPrompt(bandProfile, songDetails);
    
    const response = await this.client.messages.create({
      model: 'claude-opus-4-20250514',
      max_tokens: 4000,
      temperature: 0.8,
      messages: [{
        role: 'user',
        content: prompt
      }]
    });
    
    const content = response.content[0].text;
    
    // Clean and parse response
    const cleanContent = this.cleanJsonResponse(content);
    return JSON.parse(cleanContent);
  }
  
  buildPrompt(bandProfile, songDetails) {
    return `You are an expert songwriter creating lyrics for Track ${songDetails.trackNumber}: "${songDetails.title}" for the band ${bandProfile?.bandName || 'Unknown Band'}.

Band Profile Context:
- Genre: ${bandProfile?.primaryGenre || songDetails.primaryGenre || 'Rock'}
- Core Sound: ${bandProfile?.coreSound || 'Alternative'}
- Vocal Style: ${bandProfile?.vocalStyle?.type || 'Dynamic'}
- Album: ${bandProfile?.albumConcept?.title || 'Untitled Album'}
- Album Theme: ${bandProfile?.albumConcept?.description || 'No description'}
- Lyrical Themes: ${bandProfile?.lyricalThemes?.join(', ') || 'General themes'}
- Musical Influences: ${bandProfile?.influences?.join(', ') || 'Various influences'}

Song Context:
- Title: ${songDetails.title}
- Track Number: ${songDetails.trackNumber}
- Description: ${songDetails.description || 'No specific description'}
- AI Instructions: ${songDetails.aiInstructions || 'No specific instructions'}

Create a complete song with:
1. Song-specific description (under 100 characters for AI music platforms)
2. Complete lyrics with proper structure for AI music generation

The song should:
- Fit the band's style and the album's concept
- Have a unique theme that complements the overall album narrative
- Include proper song structure with [Intro], [Verse], [Chorus], [Bridge], [Outro] sections
- Match the vocal style and genre characteristics
- Be optimized for AI music generation platforms

Respond ONLY with valid JSON in this exact format:
{
  "songDescription": "Brief description under 100 characters about tempo, mood, and musical elements",
  "lyrics": "Complete song lyrics with proper sectioning:\\n\\n[Intro]\\n(instrumental description or lyrics)\\n\\n[Verse 1]\\nlyrics\\n\\n[Pre-Chorus]\\nlyrics\\n\\n[Chorus]\\nlyrics\\n\\n[Verse 2]\\nlyrics\\n\\n[Chorus]\\nlyrics\\n\\n[Bridge]\\nlyrics\\n\\n[Final Chorus]\\nlyrics\\n\\n[Outro]\\nlyrics"
}`;
  }
  
  cleanJsonResponse(content) {
    let cleanContent = content;
    
    // Remove markdown code blocks
    if (content.includes('```json')) {
      cleanContent = content.replace(/```json\n?/g, '').replace(/```\n?/g, '');
    } else if (content.includes('```')) {
      cleanContent = content.replace(/```\n?/g, '');
    }
    
    return cleanContent.trim();
  }
}

// src/services/AppwriteService.js
import { Client, Databases, Query } from 'node-appwrite';
import { DATABASE_CONFIG } from '../config.js';

export class AppwriteService {
  constructor(endpoint, projectId, apiKey) {
    this.client = new Client()
      .setEndpoint(endpoint)
      .setProject(projectId)
      .setKey(apiKey);
    
    this.databases = new Databases(this.client);
  }
  
  async getBand(bandId) {
    if (!bandId) return null;
    
    try {
      const band = await this.databases.getDocument(
        DATABASE_CONFIG.DATABASE_ID,
        'bands',
        bandId
      );
      
      // Parse profile data if it's a string
      if (band.profileData) {
        band.profileData = typeof band.profileData === 'string' 
          ? JSON.parse(band.profileData) 
          : band.profileData;
      }
      
      return band;
    } catch (error) {
      throw new Error(`Failed to fetch band: ${error.message}`);
    }
  }
  
  async updateSongWithLyrics(songId, lyrics, description) {
    return await this.databases.updateDocument(
      DATABASE_CONFIG.DATABASE_ID,
      'songs',
      songId,
      {
        lyrics: lyrics,
        description: description,
        status: 'completed',
        lyricsGeneratedAt: new Date().toISOString()
      }
    );
  }
  
  async updateSongStatus(songId, status, error = null) {
    const updateData = { status };
    
    if (error) {
      updateData.generationError = error;
    }
    
    return await this.databases.updateDocument(
      DATABASE_CONFIG.DATABASE_ID,
      'songs',
      songId,
      updateData
    );
  }
}

// src/utils/validation.js
export const validateSongEvent = (event) => {
  if (!event.$id) {
    throw new Error('Event missing $id');
  }
  
  if (event.$collection !== 'songs') {
    throw new Error('Not a song collection event');
  }
  
  if (event.status !== 'generating') {
    throw new Error('Song status is not "generating"');
  }
  
  return true;
};

export const validateEnvironment = () => {
  const required = [
    'APPWRITE_FUNCTION_API_ENDPOINT',
    'APPWRITE_FUNCTION_PROJECT_ID',
    'ANTHROPIC_API_KEY'
  ];
  
  const missing = required.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
};

// src/index.js
/**
 * Generate Lyrics Function
 * Triggered when a song document is updated with status 'generating'
 * 
 * This function:
 * 1. Validates the event and environment
 * 2. Fetches band context
 * 3. Generates lyrics using Anthropic
 * 4. Updates song with generated lyrics
 */
import { AnthropicService } from './services/AnthropicService.js';
import { AppwriteService } from './services/AppwriteService.js';
import { validateSongEvent, validateEnvironment } from './utils/validation.js';

export default async ({ req, res, log, error }) => {
  try {
    // Validate environment
    validateEnvironment();
    
    // Parse and validate event
    const event = req.body;
    validateSongEvent(event);
    
    const songId = event.$id;
    log(`Starting lyrics generation for song: ${songId}`);
    
    // Initialize services
    const appwrite = new AppwriteService(
      process.env.APPWRITE_FUNCTION_API_ENDPOINT,
      process.env.APPWRITE_FUNCTION_PROJECT_ID,
      req.headers['x-appwrite-key']
    );
    
    const anthropic = new AnthropicService(process.env.ANTHROPIC_API_KEY);
    
    // Get band profile if available
    let bandProfile = null;
    if (event.bandId) {
      try {
        const band = await appwrite.getBand(event.bandId);
        bandProfile = band.profileData;
      } catch (e) {
        log(`Could not fetch band profile: ${e.message}`);
        // Continue without band profile
      }
    }
    
    // Generate lyrics
    log('Generating lyrics with Anthropic...');
    const result = await anthropic.generateLyrics({
      bandProfile,
      songDetails: {
        title: event.title,
        trackNumber: event.trackNumber,
        description: event.description,
        aiInstructions: event.aiInstructions,
        primaryGenre: event.primaryGenre
      }
    });
    
    // Update song with generated lyrics
    await appwrite.updateSongWithLyrics(
      songId,
      result.lyrics,
      result.songDescription
    );
    
    log('Successfully generated and saved lyrics');
    
    return res.json({
      success: true,
      songId: songId,
      message: 'Lyrics generated successfully'
    });
    
  } catch (err) {
    error(`Error generating lyrics: ${err.message}`);
    
    // Try to update song status to failed
    if (req.body?.$id) {
      try {
        const appwrite = new AppwriteService(
          process.env.APPWRITE_FUNCTION_API_ENDPOINT,
          process.env.APPWRITE_FUNCTION_PROJECT_ID,
          req.headers['x-appwrite-key']
        );
        
        await appwrite.updateSongStatus(
          req.body.$id,
          'failed',
          err.message
        );
      } catch (updateErr) {
        error(`Failed to update error status: ${updateErr.message}`);
      }
    }
    
    return res.json({
      success: false,
      error: err.message
    });
  }
};